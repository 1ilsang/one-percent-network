# Chapter 5. 서버측의 LAN에는 무엇이 있는가?

1. 웹 서버의 설치 장소
2. 방화벽의 원리와 동작
3. 복수 서버에 리퀘스트를 분배한 서버의 부하 분산
4. 캐시 서버를 이용항 서버의 부하 분산
5. 콘텐츠 배포 서비스

### 웹 서버의 설치 장소

#### 사내에 웹 서버를 설치하는 경우

이번 장에서는 인터넷에서 서버측으로 패킷이 이동하는 상황에 대해서 설명한다.

서버를 설치하는 장소에 따라 인터넷을 빠져 나와 서버에 도착할때까지의 여정은 다르다.



**라우터에서 직접 연결하는 경우**

문제점

- IP 주소의 부족
  - 직접 연결하는 경우 사내 LAN에 설치한 기기에는 서버뿐 아니라 클라이언트에도 글로벌 주소를 할당해야한다
- 보안
  - 프로바이더에서 직접 웹서버로 패킷을 보내기때문에 공격에 무방비 상태가 된다

<img width="1430" alt="1" src="https://user-images.githubusercontent.com/46305139/98813173-1fe0f500-2467-11eb-91fb-713cd8340d40.png">





**방화벽**

방화벽은 관문의 역할을 하여 특정 조건을 걸어 그 조건에 부합하는 패킷만 보낸다. 따라서 액세스가 허가되지 않은 애플리케이션에 가는 패킷은 필터링된다. 하지만, 액세스를 허가한 애플리케이션에 보안구멍이 있으면 공격받을 위험성이 남아있다.

<img width="1415" alt="2" src="https://user-images.githubusercontent.com/46305139/98813176-21122200-2467-11eb-88f4-2e4b303260e3.png">







**데이터센터**

프로바이더 등이 운영하는 데이터센터에 서버를 설치하는 형태

인터넷의 중심 부분에 접속되어 있으므로 속도측면에 유리한점이 있다. 또한 내진 구조 및 발전 장치 등 여러 이점을 가지고 있다.

<img width="1285" alt="3" src="https://user-images.githubusercontent.com/46305139/98813179-22434f00-2467-11eb-9b50-5595a65981a1.png">





### 방화벽의 원리와 동작

패킷이 방화벽을 통과하는 것 부터 알아보자.

**방화벽의 기본 개념**

특정 서버와 해당 서버 안의 특정 애플리케이션에 액세스하는 패킷만 통과시키는 데 '패킷 필터링형' 유형의 방화벽이 가장 많이 보급되었다. 따라서 패킷 필터링형에 초점을 맞춰 설명한다.

필터링은 주로 패킷의 헤더를 이용해서 한다. - MAC, IP, TCP, UDP 헤더 등

| 수신처 IP 주소 | 수신처 포트 번호 | 송신처 IP 주소 | 송신처 포트 | TCP 컨트롤 비트    | 통과/ 차단 |
| -------------- | ---------------- | -------------- | ----------- | ------------------ | ---------- |
| 192.0.2.0/24   | 80               | -              | -           | -                  | O          |
| -              | -                | 192.0.2.0/24   | 80          | SYN = 1<br />ACK=0 | X          |
| -              | -                | 192.0.2.0/24   | 80          | -                  | O          |
| -              | -                | -              | -           | -                  | X          |

1. 클라이언트측은 어디라도 상관없이 수신처 웹 서버의 IP 주소에 일치하는 패킷은 통과
2. 웹 서버에서 인터넷으로 흐르는 패킷을 패킷의 방향이 아니라 액세스 방향으로 판단하기 위해 TCP 컨트롤 비트를 사용한다.



> 패킷 필터링형 방화벽은 수신처/송신처의 IP 주소, 송신처/수신처 포트번호, 컨트롤 비트 등으로 패킷을 필터링한다.



방화벽으론 다 막을수 없다

방화벽은 시점과 종점을 보고 판단 후 통과 하지만 패킷내부에서 공격이 가능하기 때문이다.

 

이를 위한 해결방안은 웹 서버 버전을 갱신 하는 것이다. 또 다른 방법은 장치나 소프트웨어로 패킷을 차단 하지만 알려진 거에만 가능하다.



### 복수 서버에 리퀘스트를 분배한 서버의 부하 분산

서버에 대한 액세스가 증가할때 대량의 패킷을 서버의 처리 능력이 따라잡지 못할 수도 있다.

1. Scale up
   - 서버 머신을 고성능 기종으로 교체
2. Scale out (분산 처리)
   - 복소의 서버를 사용하여 처리를 분담



리퀘스트를 웹 서버에 분배하는 구조

**1. DNS 서버에서 분배**

같은 이름으로 여러대의 웹서버를 등록해둔다.

예를 들어,

| 이름                | 클래스 | 타입 | 응답 IP 주소 |
| ------------------- | ------ | ---- | ------------ |
| www.lab.cyber.co.kr | IN     | A    | 192.0.2.60   |
| www.lab.cyber.co.kr | IN     | A    | 192.0.2.70   |
| www.lab.cyber.co.kr | IN     | A    | 192.0.2.80   |

조회 순서는 라운드 로빈 방법에 의해서 정해진다.

조회 1

- 192.0.2.60 / 192.0.2.70 / 192.0.2.80

조회 2

- 192.0.2.70 / 192.0.2.80 / 192.0.2.60

조회 3

- 192.0.2.80 / 192.0.2.60 / 192.0.2.70



**문제점**

- 서버의 상태를 알수 없어, 장애가 난 웹 서버의 IP주소를 응답할 수 있다.



**2. 로드 밸런서**

위의 문제를 피하기 위해서 고안되었다. 

DNS 서버에 웹 서버대신에 부하분산 장치를 등록한다.

<img width="1368" alt="4" src="https://user-images.githubusercontent.com/46305139/98814308-d5f90e80-2468-11eb-9b6e-b3151b3a29d0.png">

*부하 분산 장치가 어떻게 웹 서버를 선택하여 리퀘스트를 전송하는가?*

1. 단순 엑세스 인가? 복수 페이지에 걸쳐있는 엑세스인가?
2. 웹 서버의 부하량 - 시험 패킷을 웹 서버에 보내 응답시간으로 판단



리퀘스트가 복수 페이지에 걸쳐있는 경우에는 이전의 리퀘스트와 같은 웹 서버에 전송해야 한다.

이 전후 관계를 판단하기 위해서 HTTP 사양을 확장하여 HTTP 헤더 필드에 부가하는 방법이 있다. 따라서 부하 분산 장치는 이러한 정보를 조사하여 해결한다.



### 캐시 서버를 이용한 서버의 부하 분산

캐시 서버를 이용하여 부하 분산을 할 수 있다.

캐시 서버는 프록시라는 구조를 사용하여 데이터를 캐시에 저장하는 서버이다.

캐시 서버는 웹 서버로부터 받아 저장해둔 데이터를 읽기만 해서 클라이언트에 송신하므로 웹 서버에서 송신하는 것보다 빠르게 데이터를 송신할 수 있다. 단, 웹 서버에서 데이터가 변경된다면 캐시에 저장된 데이터는 쓸모없는 데이터가 된다. 그렇기 때문에 언제든지 캐시의 데이터를 이용할 수 있는 것은 아니다.



<img width="970" alt="5" src="https://user-images.githubusercontent.com/46305139/98815050-ea89d680-2469-11eb-989d-40fc30e76896.png">



**저장된 캐시가 없을 때**

(a) 클라이언트에서 캐시 서버에 보낸 리퀘스트

```html
GET /dir1/sample.htm HTTP/1.1
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.cyber.co.kr
Connection: Keep-Alive
```

(b) 캐시 서버에서 웹 서버에 전송한 리퀘스트의 내용

```html
GET /dir1/sample1.htm HTTP/1.1
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.cyber.co.kr
Connection: Keep-Alive
Via: 1.1 proxy.lab.cyber.co.kr   // 캐시 서버를 경유한 사실을 웹 서버에 알리기 위한것
```

(c) 웹 서버에서 캐시 서버에 반송한 응답의 내용

```html
HTTP/1.1 200 OK
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
Last-Modified: Wed, 30 Sep 2020 13:00:00 GMT
ETag: "5a9da-27903c726b61"
Accept-Ranges: bytes
Content-Length: 632
Connection: close
Content-Type: text/html

<html>
<head>
<meta http-equiv-"Content-Type" content="text/html"; charset=utf-8">
<title> 인터넷 탐험 여행</title>
...
```

(d) 캐시 서버에서 클라이언트에 전송한 응답의 내용

```html
HTTP/1.1 200 OK
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
Last-Modified: Wed, 30 Sep 2020 13:00:00 GMT
ETag: "5a9da-27903c726b61"
Accept-Ranges: bytes
Content-Length: 632
Connection: close
Content-Type: text/html
Via: 1.1 proxy.lab.cyber.co.kr   // 프록시를 경유한 사실을 알리기 위한 것

<html>
<head>
<meta http-equiv-"Content-Type" content="text/html"; charset=utf-8">
<title> 인터넷 탐험 여행</title>
...
```



**캐시 서버에 저장된 캐시가 있을 경우**

(a) 캐시 서버에서 웹 서버에 전송한 리퀘스트의 내용

```html
GET /dir1/sample1.htm HTTP/1.1
Accept: */*
Accept-Language: ja
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Host: www.lab.cyber.co.kr
Connection: Keep-Alive
If-modified-Since: Wed, 21 Sep 2020 10:25:52 GMT  // 웹 서버측에 데이터가 변경되었는지 확인
Via: 1.1 proxy.lab.cyber.co.kr
```

(b) 웹 서버에서 캐시 서버에 반송한 응답

```html
HTTP/1.1 304 Not Modified
Date: Wed, 7 Oct 2020 13:00:00 GMT
Server: Apache
ETag: "5a9da-27903c726b61"
Connection: close
```



### 콘텐츠 배포 서비스

서버측에 캐시 서버를 두는 방법은 웹 서버의 부하를 경감하는 효과는 있지만, 인터넷의 트래픽을 억제하는 효과는 없다.

캐시 서버의 위치

1. 서버측
   - 웹 서버 운영자가 제어할수 있다
   - 인터넷의 트래픽에는 효과가 없다
2. 클라이언트측
   - 인터넷의 트래픽을 억제하는 효과가 있다.
   - 웹 서버 운영자가 제어할 수 없다. - 캐시서버의 용량을 늘리는 등의 행위
3. 프로바이더측
   - 프로바이더와 계약하여 웹 서버 운영자가 제어할 수 있는 캐시 서버를 클라이언트측의 프로바이더에 두는 방법
   - 웹 서버 운영자가 스스로 프로바이더와 계약해서 캐시 서버를 설치하는 것은 비용면이나 노력면에서 보통 일이 아니다.
   - **콘텐츠 배포 서비스** - 캐시 서버를 설치하고, 웹 서버 운영자에게 대출하는 서비스



#### 가장 가까운 캐시 서버를 찾는 방법

**DNS 서버**

웹 서버의 IP 주소를 회답할 때 가장 가까운 캐시 서버의 IP 주소를 회답하도록 설정.

DNS 동작 순서

1. 클라이언트는 등록되어 있는 DNS 서버에 조회 메시지를 보낸다
2. DNS 서버는 웹 서버 이름 계층 구조를 조사하여, 웹 서버측에 있는 DNS 서버를 찾아 조회 메시지를 보낸다
3. 대응표를 조사하여 IP 주소를 회답



*클라이언트와 캐시 서버의 거리를 어떻게 판단하는가?*

1. 캐시 서버의 설치 장소에 있는 라우터에서 경로정보를 모아둔다.

이 경로표를 이용하여 클라이언트측의 DNS 서버에서 캐시서버까지의 경로정보를 알 수 있다. 이 데이터를 조사하여 비교하여 어느 라우터가 클라이언트와 가장 가까운지 판단할수 있다. - *클라이언트 DNS 서버와 캐시서버와의 거리이므로 정확한 거리는 아니지만 어느정도 정확하게 거리를 측정할 수 있다.*

2. [Location 헤더](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Location)

리다이렉트를 이용하여 가장 가까운 캐시 서버로 요청을 돌리는 방법이 있다.

리다이렉트용 서버를 두고 이 서버를 DNS에 등록한다. 리다이렉트용 서버에는 라우터에서 모은 경로 정보가 있으며 여기에서 가장 가까운 캐시 서버를 찾습니다. 그리고 캐시 서버를 나타내는 Location 헤더를 설정하여 응답을 보낸다.

클라이언트가 보내는 HTTP 메시지의 송신처 IP 주소를 바탕으로 거리를 판단하므로 정밀도가 높다.



