## Chapter2. TCP/IP의 데이터를 전기 신호로 만들어 보낸다 (2)

1. [서버에서 연결을 끊어 소켓을 말소한다](#서버에서-연결을-끊어-소켓을-말소한다)
2. [IP와 이더넷의 패킷 송수신 동작](#IP와-이더넷의-패킷-송수신-동작)
3. [UDP 프로토콜을 이용한 송수신 동작](#UDP-프로토콜을-이용한-송수신-동작)

### 서버에서 연결을 끊어 소켓을 말소한다

#### 연결 끊기

데이터 송수신 동작이 끝난 후 프로토콜 스택의 움직임을 설명한다.

- 애플리케이션이 송신해야 하는 데이터를 전부 송신 완료했다고 판단했을 때
- 웹의 경우, 리퀘스트 메시지를 보내고 서버에서 응답 메시지를 반송하면 데이터 송수신이 끝나므로 서버측에서 연결끊기 단계에 들어간다. (HTTP 1.0) 
  - HTTP 1.1 의 경우에는 서버가 응답메시지를 반송한 후 계속 클라이언트가 다음 리퀘스트 메시지를 보내는 것이 가능하므로, 이 때는 클라이언트 측에서 먼저 연결 끊기 단계에 들어갈 수 있다.

![4way](https://user-images.githubusercontent.com/46305139/96719431-571e3200-13e4-11eb-9c67-3b48d885e060.jpeg)



*서버 측에서 연결 끊기 단계에 들어가는 것으로 간주*

**서버**

- 서버측 애플리케이션
  - Socket 라이브러리의 *close* 를 호출
- 서버측 프로토콜 스택
  - TCP 헤더 만들고, 컨트롤 비트인 **FIN** 비트를 1로 설정
  - IP 담당 부분에 의뢰하여 클라이언트에 송신 요청
  - 서버측의 소켓에 연결 끊기 동작에 들어갔다고 기록

**클라이언트**

- 프로토콜 스택
  - 서버에서 **FIN** 1로 설정한 TCP 헤더가 도착하면 자신의 소켓에 연결 끊기 동작에 들어갔다는 것을 기록
  - 이에 해당하는 ACK 번호를 서버측에 반송후 애플리케이션이 데이터를 가지러 올 때까지 대기
- 애플리케이션
  - Socket 라이브러리의 *read* 를 호출하여 데이터를 읽기 작업 요청
- 프로토콜 스택
  - 데이터를 바로 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 애플리케이션에 통지
  - 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료
- 애플리케이션
  - Socket 라이브러리의 *close* 를 호출하여 데이터 송수신 동작을 끝낸다
- 프로토콜 스택
  - TCP 헤더 만들고, 컨트롤 비트인 **FIN** 비트를 1로 설정
  - IP 담당 부분에 의뢰하여 서버에 송신 요청
  - 서버에서의 ACK 번호를 기다리고 해당 응답을 받으면 종료



#### 소켓 말소

소켓을 바로 말소하지 않고 잠시 기다린 후 소켓을 말소 ( 오동작을 막기 위해 )



*오동작의 예시*

1. 클라이언트가 FIN 송신
2. 서버가 ACK 번호 송신
3. 서버가 FIN 송신
4. 클라이언트가 ACK 번호 송신 - *이부분에서 오류가 발생 했을 경우*

서버는 ACK 가 돌아오지 않으므로 다시한번 FIN 송신을 하게 된다.
if, 클라이언트의 소켓이 말소되면 기록되어 있던 제어정보가 없어지므로 소켓에 할당되어 있던 포트번호도 알 수 없게 된다. 또 이 시점에 **다른 애플리케이션이 생성한 소켓에 같은 포트번호가 할당**될 수 있다. 이 때 FIN을 받게 되면 **그 소켓이 연결 끊기 동작**에 들어갈 수 있다.



따라서 일반적으로 보통 몇 분 정도 기다리고 소켓을 말소 한다.

---

![tcp-process](https://user-images.githubusercontent.com/46305139/96719845-efb4b200-13e4-11eb-8238-aa017f0d2f1f.png)

> 출처: https://www.crocus.co.kr/1362



### IP와 이더넷의 패킷 송수신 동작

#### 패킷

<img width="1244" alt="header" src="https://user-images.githubusercontent.com/46305139/96720703-0e677880-13e6-11eb-8482-71a9fb68df5f.png">

TCP 담당 부분이 통신 상대와 대화할 때 IP 담당 부분에 의뢰를 한다. 이 의뢰를 받은 IP 담당 부분이 어떻게 패킷을 전송하는지 살펴보자.

*패킷의 구성*

- 헤더
  - 수신처를 나타내는 주소등의 제어정보
- 데이터
  - TCP에서 보낸 TCP 헤더를 포함한 패킷

**패킷 통신 기본 구조**

- 패킷의 송신처가 되는 기기가 패킷을 생성
- 가장 가까운 중계장치에 송신
- 중계 장치는 패킷의 헤더를 조사하여 다음 목적지를 판단
  - 수신처가 어느 방향에 있는지에 대한 정보를 기록한 표 같은것을 사용
- 최종적으로 수신처의 기기에 도착



TCP/IP 패킷 구조는 이 기본에서 발전한 것이다. *라우터* 와 *허브* 라는 두 종류의 패킷 중계장치가 역할을 분담하면서 패킷을 운반한다.



#### 패킷 송수신 동작의 개요

프로토콜 스택의 IP 담당 부분의 패킷 송신 동작에 대해 알아보자.

상대가 있는 곳까지 패킷을 운반하는 것은 허브나 라우터같은 네트워크 기기의 역할이므로 IP 담당부분은 **패킷을 상대에게 송출만** 한다.

TCP 담당 부분이 통신 상대와 대화할 때 데이터 조각에 TCP 헤더를 부가한 것을 IP 담당 부분에 건네준다. 이 부분을 한 덩어리의 디지털 데이터로 간주하고 그 앞에 제어 정보를 기록한 헤더를 부가한다

**IP 헤더 / MAC 헤더**

*IP 헤더*

- IP 프로토콜에 규정된 규칙에 따라 패킷의 목적지가 되는 액세스 대상 서버의 IP 주소를 기록

*MAC 헤더*

- 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어정보를 기록 - MAC 주소



이렇게 만들어진 패킷을 네트워크용 하드웨어(이더넷 or 무선 LAN - **LAN 어댑터**로 통칭)에 건네준다.

송신 동작

- LAN 어댑터에 0이나 1의 비트가 이어진 디지털 데이터를 보내고, LAN 어댑터가 전기나 빛의 신호 상태로 바꾸어 케이블에 송출

수신 동작은 이와 반대

- 신호 상태의 패킷을 디지털 데이터로 변환한후 IP 담당 부분에 전달



**요점**

- TCP 담당부분의 데이터 송수신 동작의 단계와 상관없이 IP 패킷은 모두 같다 
  - 제어 패킷이든, 데이터 패킷이든 역할에 상관없이 같다
- 의뢰받은 내용물을 패킷의 모습으로 만들어 상대에게 송신하거나 전달한 패킷을 수신만 한다



#### IP 헤더를 만든다

![ip header](https://user-images.githubusercontent.com/46305139/96710908-add13f00-13d7-11eb-8542-cffe469a32f1.jpg)

> IP header - 출처: http://www.ktword.co.kr/abbr_view.php?m_temp1=1859

IP 헤더에 들어가는 내용 중 가장 중요한 것은 수신처의 IP 주소이다. TCP 담당부분에서 통지된 통신 상대의 IP 주소를 그대로 설정한다. 송신처 IP 주소의 경우는 LAN 어댑터에 의해 결정된다.

IP 주소는 사실 컴퓨터에 할당되는 것이 아니라 **LAN 어댑터에 할당**되므로 여러 개의 LAN 어댑터를 장착하면 각 LAN 어댑터에 서로다른 IP 주소가 할당되기 때문이다. 따라서 LAN 어댑터가 결정되면 IP 주소가 결정된다.

패킷을 건네줄 상대를 판단하는 방법은 라우터가 IP용 표 (경로표, 라우팅 테이블) 를 사용하여 다음 라우터를 결정하는 동작과 같다. (자세한 동작은 3장에서...)

**프로토콜 번호** 라는 필드에도 값을 설정한다. 여기에는 패킷에 들어간 내용물이 어디에서 의뢰받은 것인지를 나타내는 값을 설정한다. TCP 면 06, UDP 면 17 과 같은 규칙이 정해져있다.



#### MAC 헤더를 만든다

이더넷에는 TCP/IP 개념이 통용되지 않는다. 이더넷은 TCP/IP 와 다른 구조로 패킷의 수신처를 판단하며, 이 구조를 따르지 않으면 이더넷 패킷을 운반할 수 없다. 이더넷 수신처 판단 구조로 사용하는 것이 **MAC 헤더** 이다.

**MAC 헤더 구성요소**

- 수신처 MAC 주소
- 송신처 MAC 주소
- 이더 타입(Ether Type)
  - 사용하는 프로토콜의 종류를 나타낸다.
  - 이더넷의 내용물은 IP 나 ARP 라는 프로토콜의 소켓이며, 규칙에 따라 값을 기록하게 된다.



#### ARP로 수신처 라우터의 MAC 주소를 조사

수신처의 MAC 주소를 조사하는 동작을 살펴보자

**ARP(Adress Resolution Protocol)**

- 이더넷에는 연결되어 있는 전원에게 패킷을 전달하는 브로드캐스트라는 구조 있다.
- 이 브로드캐스트를 이용하여 연결된 전원에게 MAC 주소를 조사하게 된다.
- 패킷을 보낼 때 마다 이 동작을 하면 ARP 패킷이 불어나기 때문에 ARP 캐시라고 불리는 메모리에 저장한다. (TTL: 몇분정도)

이 MAC 헤더를 IP 헤더 앞에 붙이면 패킷이 완성된다. 이 패킷을 만들기까지가 IP 담당부분의 역할이다.



#### 이더넷의 기본

이더넷

- 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
- MAC 헤더의 수신처 MAC 주소에 기억된 상대에게 패킷을 전달하고, 송신처 MAC 주소로 송신처를 나타낸 후 이더ㅏ타입으로 패킷의 내용물을 나타낸다
- 패킷의 내용물은 보지 않고 이더넷의 송수신 동작은 TCP 동작 단계에 상관 없이 모든 것에 공통이다



#### 이더넷 패킷의 송수신 동작

> IP 패킷을 전기나 빛의 신호로 변환

LAN 어댑터가 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크의 케이블에 송출한다

LAN 어댑터를 제어하기 위해 LAN 드라이버 소프트웨어가 필요하다(LAN 어댑터 제조 업체가 준비한 전용 제품을 사용)

- LAN 어댑터는 전원을 공급하면 즉시 사용할 수 있는 것이 아니라 초기화 작업이 필요하다. **여기에서 실행하는 이더넷 특유의 작업은 이더넷의 송∙수신 동작을 제어하는 MAC이라는 회로에 MAC주소를 설정하는 것이다.**

- 전 세계적으로 중복되지 않도록 일원화해서 관리한다
- LAN 어댑터의 ROM를 제조시 MAC주소 기록하므로 이것을 읽어와서 MAC 회로에 설정하는 것이다. 



#### 패킷에 3개의 제어용 데이터를 추가한다



LAN 드라이버는 IP 담당부분에서 패킷을 받으면 그것을 LAN 어댑터의 버퍼 메모리에 복사한뒤 MAC 회로에 명령을 보내면 MAC 회로의 작업이 시작된다.

MAC 회로는 송신 패킷에 총 3가지 데이터를 부가한다.

**프리 앰블**

- 송신하는 패킷을 읽을 때의 타이밍을 잡기 위한 것, 
- '10101010......' 과 같이 1과 0이 번갈아 나타나는 비트열이다
- 필요성
  - 디지털 데이터를 전기 신호로 나타낼 때 비트 값을 전압이나 전류의 값에 대응시킨다
  - 각 비트를 구별할 수 있는 클록이라는 신호가 있고, 이 클록 신호의 타이밍을 판단하는 것이 중요하다

**스타트 프레임 딜리미터**

- 프리앰블에 이어지는 비트
- 마지막 비트 패턴이 조금 다르다 - '1011'
- 패킷의 시작을 알리는 역할을 한다

**프레임 체크 시퀀스(FCS)**

- 패킷을 운반하는 도중 잡음 등의 영향으로 파형이 흐트러질 수 있다
- 이 오류를 검출하기 위한 비트열 (32비트)
- 패킷의 앞 부분부터 끝까지 어떠한 계산식에 의해 계산된 값을 넣어둔다



#### 허브를 향해 패킷을 송신한다

위의 제어용 데이터를 추가하면 케이블에 송출하는 패킷이 완성된다.

리피터 허브를 사용하는 반이중 모드의 동작을 간단히 살펴보자.

반이중 모드의 동작은 신호의 충돌을 피하기 위해 다음과 같이 동작한다.

- 케이블에 다른기기가 송신한 신호가 흐르는 지 조사후, 신호가 흐르지 않으면 송신동작 시작
- MAC 회로가 디지털 데이터를 전기 신호로 변환.
- PHY(MAU) 회로가 케이블에 송출하는 형식으로 변환하여 케이블에 송신
  - 송신뿐 아니라 수신 신호선에서 신호가 흘러들어오는지 감시



신호를 송신하고 있는 사이 수신 신호가 흘러오면 신호의 **충돌** 이 일어난다.

- 송신 동작을 중지하고 충돌 사실을 다른 기기에 알린다 - 재밍 신호
- 대기시간을 계산하여, 그 대기시간 만큼 기다린후 재전송 - MAC 주소를 바탕으로 난수를 생성하여 대기시간을 계산
- 다시 충돌시 대기 시간을 2배로 늘려 반복
- 열 번째 시도후 해결되지 않으면 오류로 판단



#### 돌아온 패킷을 받는다

패킷 수신시의 동작을 알아보자.

- 수신 동작은 수신 신호선에서 신호를 받아들이는 것부터 시작
- 프리앰블을 이용하여 타이밍 계산
- 스타트 프레임 딜리미터 후 부터 디지털 데이터로 변환하여 동작을 개시
- PHY회로에서 MAC 회로로 보낸다
- MAC회로에서 FCS 값을 검사한다. - 오류시 폐기
- MAC 헤더의 수신처 MAC 주소를 조사 - 자신의 것이 아닐시 폐기
- 본체에 통지
  - **인터럽트**라는 구조를 사용
  - 컴퓨터 본체가 실행하고 있는 작업에 끼어들어 LAN 어댑터쪽에 주의시키는 것
- LAN 드라이버가 LAN 어댑터의 버퍼 메모리에서 수신한 패킷 추출
- MAC 헤더의 프로토콜 판별
- 프로토콜에 맞는 프로토콜 스택에 건네준다



#### 서버의 응답 패킷을 IP에서 TCP로 넘긴다

웹서버에서 패킷이 돌아온 것으로 간주하고 프로토콜 스택의 동작을 추적해보자. LAN 드라이버는 tcp/ip 의 프로토콜 스택에 패킷을 건넨다

- IP 담당 부분은 IP 헤더 부분을 조사하여 포멧에 문제가 없는지 확인하고 수신처의 IP 주소를 조사한다
- 자신의 IP 주소와 동일시 TCP 담당부분에 건네준다





### UDP 프로토콜을 이용한 송수신 동작

대부분의 애플리케이션은 지금까지 설명한대로 TCP 프로토콜을 사용하여 데이터 송수신을 실행하지만 모두가 그런것은 아니다.

<img width="515" alt="tcp-udp" src="https://user-images.githubusercontent.com/46305139/96718424-f93d1a80-13e2-11eb-9cf5-b3499edf986f.png">

> 출처: https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4

![tcp-udp-img](https://user-images.githubusercontent.com/46305139/96718812-82ece800-13e3-11eb-97ca-113736e13b4c.png)

> 출처: https://juni5184.tistory.com/10



**제어용 짧은 데이터**

- DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많다
- 만약 오류 발생시 응답이 돌아오지 않으므로 다시 데이터를 요청하면 된다

**음성 및 동영상 데이터**

- 음성이나 영상 데이터는 결정된 시간안에 데이터를 건네주어야 한다
- TCP의 경우 시간이 더 걸리므로 재생 타이밍이 맞지 않을 수 있다.





