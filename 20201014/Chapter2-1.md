# Chapter2. TCP/IP의 데이터를 전기 신호로 만들어 보낸다 (1)

1. [소켓을 작성한다](#소켓을-작성한다)
2. [서버에 접속한다](#서버에-접속한다)
3. [데이터를 송수신한다](#데이터를-송수신한다)

---

## 소켓을 작성한다

### 프로토콜 스택의 내부 구성

OS에 내장된 네트워크 제어용 소프트웨어(**프로토콜 스택**)와 네트워크용 하드웨어(**LAN 어댑터**)가 브라우저에서 받는 메시지를 서버에 송출하는 동작을 탐험한다.

<img width="1344" alt="1" src="https://user-images.githubusercontent.com/46305139/95991586-e61cce80-0e67-11eb-90d1-01c2e524e5d0.png">

> 계층구조

애플리케이션의 아랫부분에는 Socket 라이브러리가 있으며, 그 안에는 리졸버가 내장

프로토콜 스택의 윗부분에는 TCP라는 프로토콜을 사용하여 데이터 송수신을 담당하는 부분과 UDP라는 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 있으며, 이 둘이 애플리케이션에서 보낸 의뢰를 받아 송수신 동작을 실행한다.

- 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송수신할 경우에는 TCP
- DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송수신할 경우에는 UDP



IP 프로토콜을 사용하여 패킷 송수신 동작을 제어하는 부분. 인터넷에서 데이터를 운반할 때는 데이터를 작게 나누어 패킷이라는 형태로 운반하는데, 이 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다.

IP 안에는 ICMP와 ARP라는 프로토콜을 다루는 부분이 포함되어 있다.

- ICMP - 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때
- ARP - IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용



LAN 드라이버

LAN 어댑터의 하드웨어를 제어한다. LAN 어댑터가 실제 송수신 동작, 즉 케이블에 대해 신호를 송수힌하는 동작을 실행한다.

### 소켓의 실체는 통신 제어용 제어 정보

**소켓**

프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 이 곳에 통신 동작을 제어하기 위한 제어 정보를 기록한다.

- 통신 상대의 IP 주소, 포트 번호
- 통신 동작이 어떤 진행 상태에 있는가

소켓은 개념적인 것이어서 실체가 없다. 제어 정보가 소켓의 실체라고 할 수 있다. 즉, 제어 정보를 기록한 메모리 영역이 소켓의 실체라 생각할 수 있다.

프로토콜 스택은 이 제어 정보를 참조하면서 동작한다.

소켓을 만든다는 동작은 제어 정보를 추가하고 상태를 기록하거나 송수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 등 통신을 준비하는 작업이다.



### Socket을 호출했을 때의 동작

<img width="1234" alt="2" src="https://user-images.githubusercontent.com/46305139/95991595-ea48ec00-0e67-11eb-93fa-b16d45bf2a4b.png">

> 메시지 송신 동작

socket 이나 connect 라는 Socket 라이브러리의 프로그램 부품을 호출했을 때 프로토콜 스택의 내부가 어떻게 움직이는지 살펴보자.

브라우저는 TCP 프로토콜을 사용하여 데이터를 송수신해 줄 것을 의뢰한므로 TCP에 대해 살펴보자.

처음은 소켓을 만드는 단계이다.

소켓 한 개 분량의 메모리 영역을 확보한다. 소켓을 만들 때 한 개의 메모리 영역을 확보하고 초기 상태라는 것을 이 영역에 기록한다. 소켓이 만들어 지면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.





## 서버에 접속한다

### 접속의 의미

**접속** 한다는 의미부터 알아보자.

이더넷이나 통신 회선은 항상 케이블이 연결되어 있으므로 언제나 신호를 보낼 수 있다. 그러므로 데이터를 신호로 변환하여 송신하기만 하면 언제든지 통신이 가능하다. 

소켓을 만든 직후는 아직 아무 것도 기록되어 있지 않으므로 통신 상대가 누구인지 모른다. 1장에서 브라우저는  URL을 바탕을 서버의 IP를 조사하고 포트번호도 정해진 규칙으로 사용하도록 정해져 있으므로 필요한 정보를 안다. 따라서 브라우저는 이러한 정보를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한 가지 역할이다.

클라이언트에서 클라이언트의 IP 주소와 포트번호라른 것을 서버측에 전달하는 것도 접속 동작의 역할 중 하나이다.



접속 동작

통신 상대와의 사이에 제어 정보를 주고 받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것

- 클라이언트측의 IP 주소나 포트 번호를 서버측에 알리는 것 등

데이터 송수신 데이터를 일시적으로 저장하는 메모리 영역(**버퍼 메모리**) 확보



### 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

![tcp-header](https://user-images.githubusercontent.com/46305139/95984392-119abb80-0e5e-11eb-8c0a-91e9a5b42a32.jpeg)

> TCP header - 출처: http://www.ktword.co.kr/abbr_view.php?nav=&m_temp1=1889&id=1103

**제어 정보**

- 클라이언트와 서버가 서로 연락을 절충하기 위해 주고 받는 제어 정보
  - 접속 동작뿐만 아니라 데이터를 송수신하는 동작이나 연결을 끊는 동작도 포함한다
  - TCP 프로토콜의 사양으로 규정하고 있다
  - 클라이언트와 서버 사이에 주고 받는 패킷의 맨 앞부분에 부가한다
  - 접속 동작의 단계에서는 데이터가 없고 패킷의 내용은 제어 정보만으로 이루어져 있다
  - 제어 정보를 패킷의 맨 앞부분에 배치하는 곳부터 **헤더**라고 부른다
- 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보
  - 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 수시로 기록된다
  - 송수신 동작의 진행 상황 등도 수시로 기록되고, 프로토콜 스택은 하나하나 차례로 정보를 참조하면서 움직안디.
  - 그러므로 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화되어 있다
  - 소켓에 기록하는 제어 정보는 프로토콜 스택을 만드는 사람에 따라 달라지므로 간단히 설명할 수 없다



클라이언트와 서버는 이 헤더에 필요한 정보를 기록하여 연락의 취하면서 통신 동작을 진행하고 있다

```
송신측 : 데이터 송신 동작을 개시합니다
수신측 : 예, 알겠습니다
송신측 : x번째 데이터를 보냅니다
수신측 : x번째 데이터를 받았습니다
(이하 생략)
```

이런 식의 대화가 헤더에 기록된 제어 정보에 의해 이루어진다.



### 접속 동작의 실제

접속동작은 애플리케이션이 Socket 라이브러리의 *connect를* 호출하는 곳부터 시작된다

```
connect(<디스크립터>, <서버측의 IP주소와 포트번호>, ......)
```



접속동작의 처음은 TCP 담당 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤드를 만드는 것입니다. 그리고 TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정합니다.



![3-way-handshake](https://user-images.githubusercontent.com/46305139/95975957-d09caa00-0e51-11eb-8c00-14e927343935.png)

> 출처 : https://gmlwjd9405.github.io/2018/09/19/tcp-connection.html



송선처와 수신처의 포트번호를 통해 송신처가 되는 클라이언트측의 소켓과 수신처가 되는 서버측의 소켓을 지정할 수 있다.



1. 클라이언트 -> 서버
   - 접속해야하는 소켓을 지정후 **컨트롤 비트**인 **SYN** 라는 비트를 1로 만든다.
   - 시퀀스 번호나 윈도우 값은 후에 설명
2. 서버 -> 클라이언트
   - 서버측의 TCP 담당부분이 TCP 헤더를 조사하여 수신처 포트번호에 해당하는 소켓을 찾아낸다
   - 해당 소켓에 필요한 정보를 기록하고 접속 동작이라는 상태로 변경 (6장에서 자세히 설명)
   - **SYN** 플래그 비트를 1로 만든다
   - **ACK** 플래그 비트를 1로 만든다. - 패킷을 받은 것을 알리기 위한 동작
     - 패킷을 받은 것을 알리기 위한 동작
3. 클라이언트 -> 서버
   - 서버로부터 받은 응답의 TCP 헤더를 조사
   - 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속완료를 나타내는 제어 정보 기록
   - ACK 플래그 비트를 1로 만든 TCP 헤더를 서버에 송신



이로써 소켓은 데이터를 송수신할 수 있는 상태가 된다. 이 때 파이프와 같은 것으로 소켓이 연결되었다고 생각할 수 있다. 이 파이프와 같은 것을 **커넥션** 이라고 한다.

이 커넥션은 *close* 를 호출하여 연결을 끊을 때까지 존재한다.





## 데이터를 송수신한다

#### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

*connect* 에서 애플리케이션에 제어가 되돌아오면 데이터 송수신 동작에 들어간다.

이 동작은 애플리케이션이 *write*를 호출하여 프로토콜 스택에 송신데이터를 건네주는 곳부터 시작한다.



- 프로토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알지 못한다
- 데이터를 곧바로 송신하지 않고 자체의 버퍼 메모리 영역에 저장하고, 다음 데이터를 기다린다
  - 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 다양하다
  - 받은 데이터를 곧바로 보내는 단순한 방법이면 작은 패킷을 많이 보낼 수도 있다.

<img width="1040" alt="3" src="https://user-images.githubusercontent.com/46305139/95991596-eae18280-0e67-11eb-981c-ad2883c63d4d.png">

> MTU 와 MSS



- 버퍼 메모리에 저장하는 정도는 몇가지 요소를 통해 판단한다
  - 한 패킷에 저장할 수 있는 데이터의 크기
    - **MTU** : 한 패킷에 저장할 수 있는 데이터의 크기 (이더넷에서는 보통 1500바이트)
    - **MSS** : 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
    - 즉, 애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 저장하게 된다.
  - 타이밍
    - 애플리케이션의 송신 속도가 느릴 경우 MSS 데이터 양만큼 데이터를 저장하는데 시간이 오래걸려 송신 동작이 지연된다
    - 내부의 타이머를 이용하여 일정 시간 이상 경과시 패킷을 송신한다
- 위의 두가지 요소는 서로 상반된다. 따라서 양자를 절충해서 송신 동작을 실행해야한다. 이에 대한 책임은 프로토콜 스택 개발자에게 맡겨져 있다
- 또한 애플리케이션에서 송신의 타이밍을 제어할수도 있다. - 데이터 송신 의뢰시 옵션을 지정 가능



### 데이터가 클 때는 분할하여 보낸다

HTTP 리퀘스트 메시지가 MSS의 길이를 초과한 길이라면, 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS 의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신한다.

<img width="1121" alt="4" src="https://user-images.githubusercontent.com/46305139/95991598-eae18280-0e67-11eb-8c89-882e4a120bd7.png">



### ACK 번호를 사용하여 패킷이 도착했는지 확인한다

TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.

![tcp](https://user-images.githubusercontent.com/46305139/95981005-01341200-0e59-11eb-885a-79771e43e7ec.gif)

> 출처 : https://whenday.tistory.com/18



TCP 담당부분은 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지를 세어둔다.

데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데 시퀀스 번호 라는 것이 이에 해당한다.

시퀀스 번호는 난수를 바탕으로 산출한 초기값으로 시작된다.

- 항상 1부터 시작하면 악의적인 공격의 우려가 있기 때문에...
- 난수로 시작시 몇번이 초기값인지 알 수 없는 문제가 있지만, 데이터 송수신 전에 초기값을 상대에게 알리게 되어 있다

이를 통해 수신측에서 패킷이 누락되었는지 확인할 수 있다.



**실제 동작 과정**

- 접속 동작을 실행할 때 클라이언트에서 서버로 보내는 데이터에 관한 시퀀스 번호의 초기값을 서버에 통지
- 서버에서 산출한 ACK 번호, 서버에서 클라이언트로 보내는 데이터에 관한 시퀀스 번호의 초기값 을 포함하여 응답
- 클라이언트에서 서버에서 받은 시퀀스 번호로 부터 ACK 번호를 산출하여 서버에 반송
- 클라이언트에서 서버로 데이터와 시퀀스 번호 를 송신
- 서버는 ACK를 응답



TCP는 이 방법으로 상대가 데이터를 받은 것을 확인한다. 그리고 확인될때 까지 송신한 패킷을 버퍼메모리에 보관해둔다. 송신한 데이터에 대응하는 ACK 번호가 상대로부터 돌아오지 않으면 패킷을 재전송한다.





### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

실제 오류 검출과 회복의 원리는 매우 복잡하다. 이 중에 요점이 되는 부분인 ACK 번호가 돌아오는 것을 기다리는 시간인 **타임아웃 값**에 대해 설명한다.

타임아웃 값이 짧을시, ACK 번호가 돌아오기 전에 다시 데이터를 보내게 된다.

타임아웃 값을 길게 설정할 시, 송수신 동작의 지연을 초래한다.

따라서, 적절한 값으로 설정해야하는데 이를 위해 TCP는 대기 시간을 동적으로 변경하는 방법을 취하고 있다.

- ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단
- 항상 ACK 번호가 돌아오는 시간을 계측해둔다.



### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다

여태까지는 한개의 패킷을 보내고 ACK 번호를 기다리는 단순한 방법에 대해 알아보았다. 하지만, 그 기다리는 아무것도 하지 않는 것은 시간낭비이기 때문에 **윈도우 제어**라는 방식에 따라 송신과 ACK 번호 통지 동작을 실행한다.

<img width="1052" alt="5" src="https://user-images.githubusercontent.com/46305139/95992883-668fff00-0e69-11eb-8789-dc358b15064a.png">

윈도우 제어는 한 개의 패킷을 보낸후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법이다.

다만 주위할 점이 있다.

- ACK 번호를 기다리지 않고 차례로 패킷을 보내면 수신측의 능력을 초과하여 패킷을 보내는 일이 발생할 수 있다.

구체적인 예

- 수신측은 TCP 패킷을 수신하면 버퍼 메모리에 데이터를 일시 보관한다
  - ACK 번호를 계산하거나 조각을 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네주기 위해
- 수신측에서 애플리케이션에 건네주는 속도보다 빠른 속도로 데이터가 도착하면 버퍼 메모리가 넘치게 된다

해결 법

- 수신측에서 송신측에 수신 가능한 데이터 양을 통지한다 - TCP 헤더의 **윈도우 필드**를 이용
- 수신 가능한 데이터 양의 최대값을 **윈도우 사이즈**라 부른다

#### 

#### ACK 번호와 윈도를 합승한다

**윈도우 통지 동작은 언제 일어나나?**

윈도우 통지가 필요한 때는 **수신측에서 버퍼 메모리에서 데이터를 애플리케이션에 건네 주었을 때**이다. (수신 버퍼의 빈 영역이 늘어났기 때문에 송신측에 통지해야한다)

ACK 번호의 경우에는 수신측에서 데이터를 정상 수신하였을 때 보낸다.

이런 두방식으로 하게 되면, 서버측에서는 패킷을 따로따로 보내야 하므로 효율성이 저하된다



**해결 법**

수신측은 ACK 번호나 윈도우를 통지할 때 바로 보내지 않고 잠시 기다린뒤, 다음 통지 동작과 함께 보낸다.

- ACK 와 윈도우 통지가 일어난 경우
  - 함께 한 개의 패킷에 실어 보낸다
- 복수의 ACK 번호 통지가 일어난 경우
  - 최후의 것만 통지하고 도중의 것은 생략한다
- 복수의 윈도우 통지가 일어난 경우
  - 최후의 것만 통지한다



### HTTP 응답 메시지를 수신한다

송신측(클라이언트) 는 HTTP 리퀘스트 메시지를 보내면 웹 서버에서 응답 메시지가 돌아오기를 기다리고, 수신을 한다.

이를 위해 브라우저는 *read* 프로그램을 호출한다.

수신작업은 위에서 설명한 것과 동일하게 동작한다.

- TCP 헤더의 내용을 조사하여 누락된 데이터를 확인하고, 문제 없을시 ACK 번호 응답
- 버퍼에 일시 보관하고 조각을 연결하여 애플리케이션 메모리 영역으로 전달